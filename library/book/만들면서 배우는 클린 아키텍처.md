---
created: 2023-01-09 21:37
tag: book
cover_url: http://image.yes24.com/goods/105138479/XL
title: 만들면서 배우는 클린 아키텍처
author: 톰 홈버그, 박소은
category: 개발
publish_date: 2021-11-26
finish_read_date:
total_page: 168
status: 읽고 있는 책
rate:
format: book
---

# 만들면서 배우는 클린 아키텍처

## 계층형 아키텍처의 문제점

데이터베이스 주도 설계를 유도한다.
- 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.
- 데이터 베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다.

지름길을 택하기 쉬워진다.
- 전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.
- 상위 계층에 위치한 컴포넌트에 접근해야 할 경우 컴포넌트를 계층 아래로 내려버리면 된다.
- 한 번 이렇게 하는 것은 괜찮을 수 있지만 계속 된다면?

테스트하기 어려워 진다.
- 계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다. 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없지않을까?
	- 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다.
	- 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 mocking해야 한다.
- 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트의 복잡도를 높인다.

usecase를 숨긴다.
- 계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
- usecase가 간단해서 도메인 계층을 생략한다면 웹 계층에 존재할 수도 있고, 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌를 아래로 내렸다면 영속성 계층에 존재할 수도 있다. 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다.

동시작업이 어려워진다.
- 계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기 떄문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다.
- 데이터 베이스 주도 설계를 하지 않을 경우에만 인터페이스를 같이 정의하고 작업할 수 있다.

이러한 문제점들을 숙지하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.

## 의존성 역전하기

### 단일 책임 원칙

단일 책임 원칙의 일반적인 해석은 다음과 같다.
> 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

실제 의도는 다음과 같다.
> 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.

- 컴포넌트를 변경할 이유가 오로지 한 가지라면 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.

### 의존성 역전 원칙

> 코드 상의 어떤 의존성이든 그 방향을 바꿀(역전시킬) 수 있다.

- 계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.

![clean_architecture_1](clean_architecture_1.png)
- 엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.
- 이제는 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성(circular dependency)이 생긴다.
- 이 부분이 의존성 역전 원칙을 적용하는 부분으로, 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다.

### 클린 아키텍처
![clean_architecture_2](clean_architecture_2.png)
- 클린 아키텍처에서 모든 의존성은 도메인 로직을 향해 안쪽 방향으로 향한다.
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다.
	- 따라서 도메인코드를 자유롭게 모델링할 수 있기 때문에 DDD를 가장 순수한 형태로 적용해볼 수도 있다.
- 도메인 계층은 영속성 계층과 같은 외부 계층과 철저하게 분리돼야 하므로 엔티티에 대한 모델을 각 계층에서 유지보수 해야한다.
	- ORM을 사용할 경우 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 각각 엔티티를 만들어야 한다.
	- 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다.
	- 이것은 결합이 제거된 상태로 바람직한 일이다. 

### 헥사고날 아키텍처
![clean_architecture_3](clean_architecture_3.png)
- 육각형 안에는 도메인 엔티티와 이와 상호작용하는 usecase가 있다.
- 육각형 밖에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있다.
- 포트와 어댑터 아키텍처로도 알려져 있다.


**클린 아키텍처, 헥사고날 아키텍처, 포트와 어댑터 아키텍처 등 무엇으로 불리든 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 외부 요인으로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유와 수를 줄일 수 있다.**

